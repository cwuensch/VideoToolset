<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>SpatialSoften / TemporalSoften Avisynth Filter</title>
   <link rel="stylesheet" type="text/css" href="../../avisynth.css">
</head>
<body >
<h2>
<a NAME="Soften"></a>SpatialSoften
/ TemporalSoften
</h2>
<p><code>SpatialSoften </code>(<var>clip, int radius, int luma_threshold, int
chroma_threshold</var>)<br>
  <code>TemporalSoften </code>(<var>clip, int radius, int luma_threshold, int
chroma_threshold, int "scenechange", int "mode"</var>)
<p>The <code>SpatialSoften</code> and <code>TemporalSoften</code>
filters remove
noise from a video clip by selectively blending pixels. These filters can
work miracles, and I highly encourage you to try them. But they can also
wipe out fine detail if set too high, so don't go overboard. And they are
very slow, especially with a large value of <var>radius</var>, so don't turn
them on until you've got everything else ready.
<p><code>SpatialSoften</code> replaces each sample in a frame with the average
of all nearby samples with differ from the central sample by no more than
a certain threshold value. "Nearby" means no more than <var>radius</var> pixels
away in the x and y directions. The threshold used is <var>luma_threshold</var>
for the Y (intensity) samples, and <var>chroma_threshold</var> for the U and
V (color) samples.
<p><code>TemporalSoften</code> is similar, except that it looks at the same
pixel in nearby frames, instead of nearby pixels in the same frame. All
frames no more than <var>radius</var> away are examined. This filter doesn't
seem to be as effective as <code>SpatialSoften</code>.
<p>I encourage you to play around with the parameters for these filters
to get an idea of what they do--for example, try setting one of the three
parameters to a very high value while leaving the others low, and see what
happens. Note that setting any of the three parameters to zero will cause
the filter to become a very slow no-op.
<p><code>TemporalSoften</code> smoothes luma and chroma separately, but <code>SpatialSoften</code>
smoothes only if both luma and chroma have passed the threshold.
<p>The <code>SpatialSoften</code> and <code>TemporalSoften</code>
filters work only with YUY2 input. You can use the <code><a href="convert.htm">ConvertToYUY2</a></code>
filter if your input is not in YUY2 format.
<p>Note that if you use AviSynth <em>v2.04</em> or above, you don't need the TemporalSoften2
plugin anymore, the built-in TemporalSoften is replaced with that implementation.
<p>Starting from<em> v2.50</em>, two options are added to <code>TemporalSoften</code>:
<ul>
  <li>
An optional <var>mode</var><i>=2</i> parameter: It has a new and better way of blending
frame and provides better quality. It is also much faster. Requires ISSE.
<var>mode=1</var>
is default operation, and works as always.</li>

  <li>
An optional <var>scenechange=n</var> parameter: Using this parameter will avoid
blending across scene changes. 'n' defines the maximum average pixel change
between frames. Good values for 'n' are between 5 and 30. Requires ISSE.</li>
</ul>
<p>Good initial values: <code>TemporalSoften</code>(4,4,8,15,2)</p>
<p><b>Changes:</b></p>
<table border="1" width="22%">
  <tr>
    <td width="7%">v2.56</td>
    <td width="93%">working also with RGB32 input</td>
  </tr>
</table>
<p><kbd>$Date: 2005/09/04 15:21:10 $</kbd>
</p>
<form><input TYPE="Button" VALUE="Back"
onClick="history.go(-1)"></form>
</body>
</html>
