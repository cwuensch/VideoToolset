<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
<!--
Automatically generated, don't change:
$Id: syntax.htm,v 1.21 2005/10/26 20:40:51 fizick Exp $ 
-->
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>AviSynth 2 - Basic Syntax</title>
<link rel="stylesheet" type="text/css" href="../avisynth.css">
</head>
<body>
<h2><a NAME="Gettingstarted"></a>Getting started</h2>
<p>Basically, AviSynth works like this: First, you create a simple text document 
  with special commands, called a script. These commands make references to one 
  or more videos and the filters you wish to run on them. Then, you run a video 
  application, such as VirtualDub, and open the script file. This is when AviSynth 
  takes action. It opens the videos you referenced in the script, runs the specified 
  filters, and feeds the output to video application. The application, however, 
  is not aware that AviSynth is working in the background. Instead, the application 
  thinks that it is directly opening a filtered AVI file that resides on your 
  hard drive. 
<p>There is much new and re-discovered functionality in AviSynth2. To make those 
  items clearly visible (especially when the feature was not well documented in 
  the past) they are marked with <strong>v2</strong> 
<p>The version 2.5 is a major internal upgrade. Read <a href="twopointfive.htm" target="main">AviSynth 
  2.5</a> carefully before you use it. Relevant changes are marked with <strong>v2.5</strong>
<h4>Linear Editing:</h4> 
<p>The simplest thing you can do with AviSynth is the sort of editing you can 
  do in VirtualDub. The scripts for this are easy to write because you don't have 
  to worry about variables and complicated expressions if you don't want. 
<p>For testing create a file called test.avs and put the following single line 
  of text in it:
<pre>Version</pre>
<p>Now open this file with e.g. Windows Media Player and you should see a ten-second 
  video clip showing AviSynth's version number and a copyright notice. 
<p><code>Version</code> is what's called a "source filter", meaning that it generates 
  a clip instead of modifying one. The first command in an AviSynth script will 
  always be a source filter. 
<p>Now add a second line to the script file, so that it reads like this: <br>
  &nbsp; 
<pre>Version
ReduceBy2&nbsp;</pre>
<p>Reopen the file in Media Player. You should see the copyright notice again, 
  but now half as large as before. <br>
  <code><a href="corefilters/reduceby2.htm">ReduceBy2</a></code> is a "transformation filter," meaning that it takes the previous 
  clip and modifies it in some way. You can chain together lots of transformation 
  filters, just as in VirtualDub. <br>
  Let's add another one to make the video fade to black at the end. Add another 
  line to the script file so that it reads: 
<pre>Version
ReduceBy2
FadeOut(10)</pre>
<p>Now reopen the file. The clip should be the same for the first 9 seconds, and 
  then in the last second it should fade smoothly to black. <br>
  The <a href="corefilters/fade.htm">FadeOut</a> filter takes a numerical argument, which indicates the 
  number of frames to fade. 
<p>It takes a long time before the fade starts, so let's trim the beginning of 
  the clip to reduce the wait, and fade out after that. <br>
 Let's discard 
  the first 120 of them, and keep the frames 120-150: <br>
  &nbsp; 
<pre>Version
ReduceBy2
Trim(120,150) # chop off the first 119 frames, and keep the frames 120-150 (AviSynth starts numbering frames from 0)
FadeOut(10)</pre>
<p>In this example we used a comment for the first time. <br>
  Comments start with the # character and continue to the end of the line, and 
  are ignored completely by AviSynth. <br>
  The <a href="corefilters/trim.htm">Trim</a> filter takes two arguments, separated by a comma: the first 
  and the last frame to keep from the clip. If you put 0 for the last frame, it's 
  the same as "end of clip," so if you only want to remove the first 119 frames
you should use Trim(120,0). 
<p>Keeping track of frame numbers this way is a chore. It's much easier to open 
  a partially-completed script in an application like VirtualDub which will display 
  the frame numbers for you. You can also use the <a href="corefilters/showframes.htm"> ShowFrameNumber</a> filter, which 
  prints each frame's number onto the frame itself. 
<p>In practice a much more useful source filter than <a href="corefilters/version.htm">Version</a> is
<a href="corefilters/avisource.htm">AVISource</a>, 
  which reads in an AVI file (or one of several other types of files) from disk. 
  If you have an AVI file handy, you can try applying these same filters to your 
  file: <br>
  &nbsp; 
<pre>AVISource(&quot;d:\capture.avi&quot;)&nbsp;&nbsp; # or whatever the actual pathname is
ReduceBy2
FadeOut(15)
Trim(120,0)</pre>
<p>Even a single-line script containing only the AVISource command can be useful 
  for adding support for >2GB AVI files to applications which only support &lt;2GB 
  ones. <br>
<hr>
<h4>Non-Linear Editing:</h4> 
<p>Now we're getting to the fun part. Make an AVS file with the following script 
  in it: 
<pre>StackVertical(Version, Version)</pre>
<p>Now open it. Result: An output video with two identical lines of version information, 
  one on top of the other. <br>
  Instead of taking numbers or strings as arguments, <a href="corefilters/stack.htm">StackVertical</a> takes 
  video clips as arguments. In this script, the Version filter is being called 
  twice. Each time, it returns a copy of the version clip. These two clips are 
  then given to <a href="corefilters/stack.htm">StackVertical</a>, which joins them together (without knowing 
  where they came from). 
<p>One of the most useful filters of this type is <a href="corefilters/splice.htm">UnalignedSplice</a>, which 
  joins video clips end-to-end. Here's a script which loads three AVI files (such 
  as might be produced by AVI_IO) and concatenates them together. 
<pre>UnalignedSplice(AVISource(&quot;d:\capture.00.avi&quot;), AVISource(&quot;d:\capture.01.avi&quot;), AVISource(&quot;d:\capture.02.avi&quot;))</pre>
<p>Both <a href="corefilters/stack.htm">StackVertical</a> and <a href="corefilters/splice.htm">UnalignedSplice</a>
can take as few as 
  two arguments or as many as sixty. <br>
  You can use the <code>+</code> operator as a shorthand for <a href="corefilters/splice.htm">UnalignedSplice</a>. 
<p>For example, this script does the same thing as the previous example: 
<pre>AVISource(&quot;d:\capture.00.avi&quot;) + AVISource(&quot;d:\capture.01.avi&quot;) + AVISource(&quot;d:\capture.02.avi&quot;)</pre>
<p>Now let's suppose you're capturing with an application that also saves the 
  video in multiple AVI segments, but puts the audio in a separate WAV file. <br>
  Can we recombine everything? You bet: 
<pre>AudioDub(AVISource(&quot;d:\capture.00.avi&quot;)+AVISource(&quot;d:\capture.01.avi&quot;)+AVISource(&quot;d:\capture.02.avi&quot;), WAVSource(&quot;d:\audio.wav&quot;))</pre>
<hr>
<h2><a NAME="Syntax"></a>Syntax </h2>
<h4>Expressions:</h4> 
<p>An AviSynth script consists of multiple lines of statements looking like this: 
  &nbsp; 
<pre>variable_name = expression</pre>
<p>In this example expression is evaluated and the result is assigned to variable_name. 
<p>Very important is the common shortcut form: 
<pre>expression</pre>
<p>In this case, expression is evaluated and the result is assigned to the special 
  clip variable <var>last</var>. <br>
  This is the same as 
<pre>last = expression</pre>
<p>The end of the script often looks like: 
<pre>return expression</pre>
<p>Here expression is evaluated and is used as the "return value" of the script--that 
  is, the video clip that will be seen by the application which opens the AVS 
  file.
<p>If "return" is not specified explicitly, the clip <var>last</var> is used as a "return value".</p> 
<p>The basic form of an expression which invokes a function is 
<pre>Function(args)</pre>
<p>Clip functions always produce a new video clip and never modify an existing 
  one, <br>
  Args is a list of function arguments separated by commas. The list can be empty 
  (which means all or some arguments can be optional) 
<p>If the filter function expects a video clip as its first argument, and that 
  argument is not supplied, then the clip in the special variable <var>last</var 
  will be used. 
><p>AviSynth filters can take named arguments. The named arguments can be specified 
  in any order, <br>
  and the filter will choose default values for any that you leave off (named 
  arguments are always optional). <br>
  This makes certain filters much easier to use. 
<pre>You can write

Subtitle(&quot;Hello, World!&quot;, text_color=$00FF00, x=100, y=200)

instead of

Subtitle(&quot;Hello, World!&quot;, 100, 200, 0, 999999, &quot;Arial&quot;, 24, $00FF00)</pre>
<p>An alternate syntax (called "OOP notation") for clip functions is 
<pre>expression.Function(args)

e.g.:
Version.ReduceBy2.FadeOut(15)</pre>
<p>This is equivalent to 
<pre>Function(expression, args)

e.g.:
FadeOut(15, ReduceBy2(Version))</pre>
<p>and can be thought of <code>Function</code> applied to <code>expression</code>. <br>
  One disadvantage of OOP notation is that it can only be used with filters which 
  take a single video-clip argument, not with filters which take several. 
<p>All AviSynth functions produce defined number of output frames and framerate, 
  even if the statement seems very complex. <br>
  AviSynth knows after having read the script how long the output will be, which 
  framerate it has and the "cutting sequence" of all used inputs <br>
  This is all calculated on opening the script. Only the actual filtering is done 
  runtime on request. <br>
<hr>
<p><b>Comments</b>: AviSynth ignores anything from a # character to the end of 
  that line. 
<p><b>Ignore Case</b>: aViSouRCe is just as good as AVISource. 
<p><b>Continue</b> on next or from previous line: \ 
 
<pre>Subtitle (&quot;Test-Text&quot;)

Subtitle ( \
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Test-Text&quot;)

Subtitle (&nbsp;
       \ &quot;Test-Text&quot;)</pre>
<p> 
<hr>
<h4>Variables:</h4> 
<p>A variable name can be up to 50 characters long and can contain letters, digits, 
  and underscores (_), but no other characters. The name cannot start with a digit. 
<p>The following types of variables can be used: 
<p><var>clip</var>: a video clip containing video and / or audio. At least one 
  variable for a clip must be used and returned by the script. <br>
  <var>string</var>: surrounded either by "quotation marks" or by 3 quotation 
  marks like &quot;&quot;&quot;this example&quot;&quot;&quot;. A text string can 
  contain any character except the terminating quotation mark or double-apostrophe. 
  If you need to put a quotation mark inside a string, use the triple quote-notation:
<pre>Subtitle (&quot;&quot;&quot;This displays &quot;hello world&quot; with quotes&quot;&quot;&quot;)</pre>
<p><var>int:</var> entered as a string of digits, optionally with a + or - at 
  the beginning. <br>
  <var>float:</var> entered as a string of digits with a period (.) somewhere 
  in it and an optional + or -. For example, +1. is treated as a floating-point 
  number. <br>
  <var>val:</var> as type of a function argument where it does not matter if it 
  is int or float <br>
  <var>bool</var>: can be TRUE or FALSE <br>
  <var>hexadecimal numbers</var>: entered by preceding it with a $. This variable 
  is treated as an integer. Several filters use this notation for specifying colors. 
  For example, $FF8800 is a shade of orange. 
<p><var>global</var>: defines a global variable, which can be used by all user-defined 
  functions and the main script in common.
<p>Here's another version of the example from above that's more manageable and 
  easier to understand: 
<pre>a = AVISource(&quot;d:\capture.00.avi&quot;)
b = AVISource(&quot;d:\capture.01.avi&quot;)
c = AVISource(&quot;d:\capture.02.avi&quot;)
sound_track = WAVSource(&quot;d:\audio.wav&quot;)

AudioDub(a+b+c, sound_track)</pre>
<hr>
<h2> 
<a name="Colors"></a>Colors</h2>
<p> 
In some filters (BlankClip, Letterbox, AddBorders and FadeXXX) a color argument
can specified. In all cases the color should be specified in RGB format even if
the colorformat of the input clip is YUV. This can be done in decimal or
hexadecimal notation. The decimal (hexadecimal) notation is as follows: the
first three (two) numbers denote the red channel, the next three (two) the green
channel and the last three (two) the blue channel. The hexadecimal number should
be preceded with a $.
<p> 
Let's consider an example. Brown is given by R=165, G=42, B=42. Thus
BlankClip(color=165042042) gives a brown frame. Converting each channel to
hexadecimal (remember that A=10, B=11, C=12, D=14, E=14, F=15) gives
<pre>R = 165 = A*16^1 + 5*16^0 = A5
G = 42 = 2*16^1 + A = 2A
B = 42 = 2*16^1 + A = 2A</pre>
<p> 
Thus creating a brown frame specifying the color in hexadecimal notation gives
BlankClip(color=$A52A2A).
<p> 
Note that black RGB=$000000 will be converted to Y=16, U=V=128 if the
colorformat of the input clip is YUV, since the default color conversion RGB
[0,255] -&gt; YUV [16,235] is used. 
<hr>
<h2><a NAME="Operators"></a>Operators </h2>
<p>For all types of operands (clip, int, float, string, bool) you can use: <br>
  <code>==</code> is equal <br>
  <code>!=</code> not equal 
<p>For numeric types (int, float): <br>
  <code>+ </code>add <br>
  <code>- </code>subtract <br>
  <code>* </code>multiply <br>
  <code>/ </code>divide <br>
  <code>% </code>mod <br>
  <code>>=</code> greater or equal than <br>
  <code>&lt;=</code> less or equal than <br>
  <code>&lt; </code>less than <br>
  <code>> </code>greater than </p>
<pre>AviSynth in former versions parsed expressions from right to left, which gave  unexpected results: 

 a = 10 - 5 - 5 resulted in 10 - (5 - 5) = 10 instead of (10 - 5) - 5 = 0 !
 
This bug has been corrected!
Starting from v2.53 also multiplication and division are parsed from left to right (instead of right to left). </pre>
<p>For string type: <br>
  <code>+ </code>add <br>
  <code>>=</code> greater or equal than (case-insensitive) <br>
  <code>&lt;=</code> less or equal than (case-insensitive) <br>
  <code>&lt; </code>less than (case-insensitive) <br>
  <code>> </code>greater than (case-insensitive) 
<p>For clip type: <br>
  <code>+ </code>the same as the function <code>UnalignedSplice</code> <br>
  <code>++</code> the same as the function <code>AlignedSplice</code> 
<p>For bool type (true/false):<br>
<code>||</code> or <br>
  <code>&amp;&amp;</code> and <br>
  <code>?:</code> execute code conditionally 
<pre>b = (a==true) ? 1 : 2

This means in pseudo-basic:

if (a=true) then b=1 else b=2&nbsp;</pre>
<hr>
<h2><a NAME="ScriptFunctions"></a>Script Functions </h2>
<p>The input and output of these functions are not clips, but some other variables 
  used in the script. 
<h4>Numerical functions:</h4>
<table BORDER WIDTH="75%" >
  <tr> 
    <td WIDTH="62%"><code>MulDiv(<var>int, int, int</var>)</code>: (m*n+d/2)/d with 64 bit intermediate result</td>
    <td WIDTH="40%"><code>MulDiv</code> (1, 1, 2) = 1<br>
      <code>MulDiv</code> (2, 3, 2) = 3</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Floor(<var>float</var>)</code>: converts from float to int</td>
    <td WIDTH="40%"><code>Floor</code> (1.2) = 1<br>
      <code>Floor</code> (1.6) = 1<br>
      <code>Floor</code> (-1.2) = -2<br>
      <code>Floor</code> (-1.6) = -2</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Ceil</code> (<var>float</var>): converts from float 
      to int</td>
    <td WIDTH="40%"><code>Ceil</code> (1.2) = 2.0<br>
      <code>Ceil</code> (1.6) = 2.0<br>
      <code>Ceil</code> (-1.2) = -1<br>
      <code>Ceil</code> (-1.6) = -1</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Round</code> (<var>float</var>): converts from float 
      to int</td>
    <td WIDTH="40%"><code>Round</code> (1.2) = 1<br>
      <code>Round</code> (1.6) = 2<br>
      <code>Round</code> (-1.2) = -1<br>
      <code>Round</code> (-1.6) = -2</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Int</code> (<var>float</var>): Converts from float to int (round towards zero).</td>
    <td WIDTH="40%"><code>Int</code> (1.2) = 1<br>
      <code>Int</code> (1.6) = 1<br>
      <code>Int</code> (-1.2) = -1<br>
      <code>Int</code> (-1.6) = -1</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Float</code> (<var>int</var>): Converts int to float.</td>
    <td WIDTH="40%">&nbsp;</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Frac</code> (<var>float</var>): Returns the fractional portion of the value provided.</td>
    <td WIDTH="40%"><code>Frac</code> (3.7) = 0.7<br>
      <code>Frac</code> (-1.8) = -0.8</td>
  </tr>
  <tr> 
    <td WIDTH="62%" HEIGHT="4"><code>Abs</code> (<var>integer</var>) / <code>Abs</code> 
      (<var>float</var>): Returns the absolute value (returns float for float, integer for integer).</td>
    <td WIDTH="40%" HEIGHT="4"><code>Abs</code> (-1.8) = 1.8</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Sign</code> (<var>int</var>) / <code>Sign</code> (<var>float</var>):
      Returns sign of value (1, 0 or -1).</td>
    <td WIDTH="40%"><code>Sign</code>(-3.5) = -1<br>
      <code>Sign</code>(3.5) = 1<br>
      <code>Sign</code>(0) = 0</td>
  </tr>
  <tr> 
    <td WIDTH="62%" HEIGHT="24"><code>HexValue</code> (<var>string</var>) Evaluates string as hexadecimal value.</td>
    <td WIDTH="40%" HEIGHT="24"><code>HexValue</code> ("FF00") = 65280</td>
  </tr>
  <tr> 
    <td COLSPAN="2"></td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Sin</code> (<var>float</var>) Returns the sine of the argument (assumes it is radians).</td>
    <td WIDTH="40%">    Sin(Pi()/4) = 0.707&nbsp;<br>
    Sin(Pi()/2) = 1.0</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Cos</code> (<var>float</var>) Returns the cosine of the argument (assumes it is radians).</td>
    <td WIDTH="40%">    Cos(Pi()/4) = 0.707&nbsp;<br>
    Cos(Pi()/2) = 0.0</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Pi</code> () Returns the value of the "pi" constant (the ratio of a circle's perimeter to its diameter).</td>
    <td WIDTH="40%">d = Pi() # d == 3.141593</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Log</code> (<var>float</var>) Returns the natural (base-e) logarithm of the argument.</td>
    <td WIDTH="40%">    Log(1) = 0.0&nbsp;<br>
    Log(10) = 2.30259</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Exp</code> (<var>float</var>) Returns the natural (base-e) exponent of the argument.</td>
    <td WIDTH="40%">    Exp(1) = 2.718282&nbsp;<br>
    Exp(0) = 1.0</td>
  </tr>
  <tr> 
    <td WIDTH="62%" HEIGHT="24"><code>Pow</code> (<var>float base, float power</var>)
      Returns "base" raised to the power indicated by the second argument.</td>
    <td WIDTH="40%" HEIGHT="24">    Pow(2, 3) = 8&nbsp;<br>
    Pow(3, 2) = 9&nbsp;<br>
    Pow(3.45, 1.75) = 8.7334</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Sqrt</code> (<var>float</var>} Returns the square root of the argument.</td>
    <td WIDTH="40%">    Sqrt(1) = 1.0&nbsp;<br>
    Sqrt(2) = 1.4142</td>
  </tr>
  <tr> 
    <td COLSPAN="2"></td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Rand</code> (<var>[int max] [, bool scale] [, bool seed]</var>): 
      returns random integer between 0 and max.<br>
      &nbsp; defaults: max = 32768 <br>
      &nbsp; scale = TRUE ( TRUE = normal mode, FALSE = modulus mode) <br>
      &nbsp; seed = FALSE (TRUE = use time as seed)</td>
    <td WIDTH="40%"><code>Rand</code>(100) = integer number between 0 and 99</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Spline</code> (<var>float X,&nbsp; x1,y1, x2,y2, ...., 
      bool "cubic"</var>}<strong> v2.5</strong> <br>
      &nbsp;Interpolates the Y value at point X using the control points x1/y1,... 
      <br>
      &nbsp;There have to be at least 2 x/y-pairs. <br>
      &nbsp;The interpolation can be cubic (the result is a spline) or linear 
      (the result is a polygon)</td>
    <td WIDTH="40%"><code>Spline</code> (5, 0,0, 10,10, 20,0, false) = 5<br>
      <code>Spline</code> (5, 0,0, 10,10, 20,0, true) = 7</td>
  </tr>
</table>
<h4>String functions:</h4>
<table BORDER WIDTH="80%" >
  <tr> 
    <td WIDTH="53%"><code>UCase</code> (<var>string</var>): returns the string 
      in uppercase</td>
    <td WIDTH="60%"><code>UCase</code> ("AviSynth") = "AVISYNTH"</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>LCase</code> (<var>string</var>): returns the string 
      in lowercase</td>
    <td WIDTH="60%"><code>LCase</code> ("AviSynth") = "avisynth"</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>RevStr</code> (<var>string</var>): returns the string 
      in reverse</td>
    <td WIDTH="60%"><code>RevStr</code> ("AviSynth") = "htnySivA"</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>StrLen</code> (<var>string</var>): returns the length 
      of string</td>
    <td WIDTH="60%"><code>StrLen</code> ("AviSynth") = 8</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>Findstr</code> (<var>string1, string2</var>):<br>
      returns the offset of string2 inside string1. The search is case-sensitive.</td>
    <td WIDTH="60%"><code>Findstr</code> ("AviSynth","syn") = 4</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>LeftStr</code> (<var>string, length</var>) / <code>RightStr</code> 
      (<var>string, length</var>):<br>
      returns left or right portion of string specified by length</td>
    <td WIDTH="60%"><code>LeftStr</code> ("AviSynth",3) = "Avi"</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>MidStr</code> (<var>string, start [, length]</var>):<br>
      returns portion of string starting at start (for the first character start=1) 
      for the number of characters specified by length or to the end.</td>
    <td WIDTH="60%"><code>MidStr</code> ("AviSynth",3,2) = "iS"</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>VersionNumber</code> ()</td>
    <td WIDTH="60%"><code>VersionNumber</code> () = 2.07</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>VersionString</code> ()</td>
    <td WIDTH="60%"><code>VersionString</code> () = "AviSynth 2.08 (avisynth.org) 
      22 nov. 2002"</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>Chr</code> (<var>int</var>): returns the ASCII character 
      <strong>v2.5</strong></td>
    <td WIDTH="60%"><code>Chr</code> (34) returns the quote character</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>Time</code> (<var>string</var>): returns a string with 
      the current system time formatted as defined by the string <strong>v2.5</strong></td>
    <td WIDTH="60%">Codes for output formatting <br>
      %a Abbreviated weekday name <br>
      %A Full weekday name <br>
      %b Abbreviated month name <br>
      %B Full month name <br>
      %c Date and time representation appropriate for locale <br>
      %d Day of month as decimal number (01 – 31) <br>
      %H Hour in 24-hour format (00 – 23) <br>
      %I Hour in 12-hour format (01 – 12) <br>
      %j Day of year as decimal number (001 – 366) <br>
      %m Month as decimal number (01 – 12) <br>
      %M Minute as decimal number (00 – 59) <br>
      %p Current locale‚s A.M./P.M. indicator for 12-hour clock <br>
      %S Second as decimal number (00 – 59) <br>
      %U Week of year as decimal number, with Sunday as first day of week (00 
      – 53) <br>
      %w Weekday as decimal number (0 – 6; Sunday is 0) <br>
      %W Week of year as decimal number, with Monday as first day of week (00 
      – 53) <br>
      %x Date representation for current locale <br>
      %X Time representation for current locale <br>
      %y Year without century, as decimal number (00 – 99) <br>
      %YYear with century, as decimal number <br>
      %z, %Z Time-zone name or abbreviation; no characters if time zone is unknown 
      <br>
      %% Percent sign&nbsp; 
      <p>The # flag may prefix any formatting code. In that case, the meaning 
        of the format code is changed as follows. 
      <p>%#a, %#A, %#b, %#B, %#p, %#X, %#z, %#Z, %#% # flag is ignored.&nbsp; 
        <br>
        %#c Long date and time representation, appropriate for current locale. 
        For example: “Tuesday, March 14, 1995, 12:41:29„.&nbsp; <br>
        %#x Long date representation, appropriate to current locale. For example: 
        “Tuesday, March 14, 1995„.&nbsp; <br>
        %#d, %#H, %#I, %#j, %#m, %#M, %#S, %#U, %#w, %#W, %#y, %#Y Remove leading 
        zeros (if any).
    </td>
  </tr>
</table>
<h4>Conversions:</h4>
<table BORDER WIDTH="75%" >
  <tr> 
    <td width="50%"><code>Value</code> (<var>string</var>): Returns the value 
      of an string.</td>
    <td WIDTH="50%"><code>Value</code> ( "-2.7" ) = -2.7</td>
  </tr>
  <tr> 
    <td width="50%"><code>String</code> (<var>float / int / string, format_string</var>): converts 
      a number to a string.<br>
      <p>If the variable is float or integer, 
  it converts it to a float and uses the format_string to convert it to a string.</p>
      <p>The syntax of the format_string is as follows:</p>
      <p>%[flags][width][.precision]f<br>
  width: the minimum width (the string is never truncated)<br>
  precision: the number of digits printed<br>
  flags:<br>
  <tt>&nbsp;-&nbsp;&nbsp;&nbsp;</tt>left align (instead right align)<br>
  <tt>&nbsp;+&nbsp;&nbsp;&nbsp;</tt>always print the +/- sign<br>
  <tt>&nbsp;0&nbsp;&nbsp;&nbsp;</tt>padding with leading zeros<br>
  <tt>&nbsp;'&nbsp;'&nbsp;</tt>print a blank instead of a &quot;+&quot;<br>
  <tt>&nbsp;#&nbsp;&nbsp;&nbsp;</tt>always print the decimal point</p>
    </td>
    <td WIDTH="50%">e.g. <code>Subtitle</code> ("Clip height is " + <code>String</code> 
      (last.height) )<br>
      <br>
      <code>String</code>(1.23, &quot;%f&quot;) =      '1.23'<br>
      <code>String</code>(1.23, &quot;%5.1f&quot;) =   '  1.2'<br>
      <code>String</code>(1.23, &quot;%1.3f&quot;)  = '1.230'
    </td>
  </tr>
</table>
<h4>Test functions:</h4> 
<p><code>IsBool(<var>var</var>) </code><br>
  <code>IsInt(<var>var</var>) </code><br>
  <code>IsFloat(<var>var</var>) </code><br>
  <code>IsString(<var>var</var>) </code><br>
  <code>IsClip(<var>var</var>) </code>
<h4>Other functions:</h4> 
<p><code>Select</code> (<var>index, item0 [, item1...]</var>): Returns item selected 
  by the index (0=item0). Items can be any variable or clip and can even be mixed.<br>
  <code>Defined</code> (<var>var</var>): for defining optional parameters in user-defined 
  functions. <br>
  <code>Default</code> (<var>x, d</var>): returns x if Defined(x), d otherwise. 
  <br>
  <code>Exist</code> (<var>filename</var>): returns TRUE or FALSE after checking 
  if the file exists.<br>
  <code>NOP</code> (): returns NULL, provided mainly for conditional execution 
  with non-return value items such as import and no "else" condition desired.<br>
  <code>Eval</code> (<var>string</var>),<br>
  <code>Apply</code> (<var>func-string, arg,...</var>): <code>Eval</code> ("f(x)") 
  is equivalent to <code>f(x)</code> is equivalent to <code>Apply</code> ("f", 
  x)
<pre>You can use Eval for something like:
settings = &quot;352, 288&quot;
Eval( &quot;BicubicResize(&quot; + settings + &quot;)&quot; )</pre>
<p><code>Import</code>(<var>filename</var>): evals contents of another AviSynth 
  script (imports the text of another script) 
<p>For error reporting and catching bad input to user-defined function you can 
  use: <br>
  <code>Assert</code>(<var>bool, string error-message</var>) 
<p><code>Try ... Catch</code>: this is a function for checking if an error WILL 
  arise:
<pre>Try {
&nbsp; AviSource(&quot;file.avi&quot;)
}
Catch(err_msg) {
&nbsp;&nbsp; Blackness.Subtitle(err_msg)
}</pre>
<hr>
<h2><a NAME="RuntimeFunctions"></a>Runtime Functions</h2>
<p>There are now <a href="corefilters/conditionalfilter.htm" target="main">Conditional 
  Filters</a> which evaluate scripts when a frame is processed, so you can change 
  variables on a per-frame basis. <br>
  To have more applications there have to be <a href="corefilters/conditionalfilter.htm#RuntimeFunctions" target="main">Runtime 
  Functions</a> which evaluate the content of the clip and return a value. <strong>v2.5</strong> 
  <br>
  &nbsp; 
<pre>A simple example is to calculate the average luma for each frame and display it.


Version()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # generate a test clip
ConvertToYV12&nbsp;&nbsp; # we need YV12
FadeIn(10)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # make the luma variable so we see something happen

ScriptClip(&quot; Subtitle(String(AverageLuma())) &quot;)&nbsp; # evaluate Subtitle(...) for each frame
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # the output of AverageLuma is converted to a string
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # and Subtitled on the input clip
ConvertToRgb&nbsp;&nbsp;&nbsp; # view it in RGB</pre>
<hr>
<h2><a NAME="ControlFunctions"></a>Control Functions </h2>
<p><code>SetMemoryMax</code> (<var>int</var>): Sets the maximum memory that AviSynth 
  uses (in MB)<strong> v2</strong></p>

<p>In some versions there is a default setting of 5MB, which is quite low. If you 
  encounter problems (e.g. low speed) try to set this values to at least 32MB.
  Return value: Actual MemoryMax value set.</p> 

<p><code>SetPlanarLegacyAlignment</code> (<var>clip, bool</var>): Set alignment mode for
  planar frames. <strong>v2.5.6</strong></p>

<p>Some older plugins illegally assume the layout of video frames in memory. This special
  filter forces the memory layout of planar frames to be compatible with prior version of
  AviSynth. The filter works on the GetFrame() call stack, so it effects filters
  <strong>before</strong> it in the script.</p>

<pre><strong>Example : Using an older version of Mpeg2Source()</strong>

LoadPlugin(&quot;...\Mpeg2Decode.dll&quot;)
Mpeg2Source(&quot;test.d2v&quot;)         # A plugin that illegally assumes the layout of memory
SetPlanarLegacyAlignment(true)  # Set legacy memory alignment for prior statements
ConvertToYUY2()                 # Statements thru to the end of the script have
...                             # advanced memory alignment.</pre>

<p><code>SetWorkingDir</code> (<var>string</var>): Sets the default directory 
  for Avisynth. <strong>v2</strong></p>

<p>This is primarily for easy loading of source clips, etc. Does not affect plugin 
  autoloading. Return value: 0 if successful, -1 otherwise.</p>
<hr>
<h2><a NAME="ClipProperties"></a>Clip Properties</h2>
<p>These functions take a clip as input and you get back a property of the clip. 
<p><code>Width</code> (<var>clip</var>)<br>
  <code>Height</code> (<var>clip</var>)<br>
  <code>Framecount</code> (<var>clip</var>)<br>
  <code>Framerate</code> (<var>clip</var>)<br>
  <code>FramerateNumerator</code> (<var>clip</var>) <strong>v2.55</strong><br>
  <code>FramerateDenominator</code> (<var>clip</var>) <strong>v2.55</strong><br>
  <code>Audiorate</code> (<var>clip</var>)<br>
  <code>Audiolength</code> (<var>clip</var>) - (note: 2^31 samples limit)<br>
  <code>AudiolengthF</code> (<var>clip</var>) - (will return the samplenumber as float) <strong>v2.55</strong><br>
  <code>Audiochannels</code> (<var>clip</var>)<br>
  <code>Audiobits</code> (<var>clip</var>)<br>
  <code>IsAudioFloat</code> (<var>clip</var>) <strong>v2.55</strong><br>
  <code>IsAudioInt</code> (<var>clip</var>) <strong>v2.55</strong><br>
  <code>IsRGB</code> (<var>clip</var>)<br>
  <code>IsRGB24</code> (<var>clip</var>)<br>
  <code>IsRGB32</code> (<var>clip</var>)<br>
  <code>IsYUY2</code> (<var>clip</var>)<br>
  <code>IsYV12</code> (<var>clip</var>) <strong>v2.51</strong><br>
  <code>IsYUV</code> (<var>clip</var>) <strong>v2.54</strong> <br>
  <code>IsPlanar</code> (<var>clip</var>) <strong>v2.51</strong> <br>
  <code>IsInterleaved</code> (<var>clip</var>) <strong>v2.51</strong> <br>
  <code>IsFieldBased</code> (<var>clip</var>)<br>
  <code>IsFrameBased</code> (<var>clip</var>)<br>
  <code>GetParity</code> (<var>clip</var>) <br>
  <code>HasAudio</code> (<var>clip</var>) <strong>v2.56</strong> <br>
  <code>HasVideo</code> (<var>clip</var>) <strong>v2.56</strong> <br>
<pre>Don't forget: you can use the Properties with the implicit variable LAST or in OOP-notation:

BilinearResize(Width/2, Height/2)
&nbsp;&nbsp; is the same as
BilinearResize(Width(Last)/2, Height(Last)/2)
&nbsp;&nbsp; is the same as
BilinearResize(Last.Width / 2, Last.Height / 2)</pre>
<p> 
<hr>
<h2><a NAME="userdefined"></a>User-Defined Functions </h2>
<p>You can define your own functions. This is best explained by an example: <br>
  &nbsp; 
<pre>Function NTSC2PAL( clip c) {
&nbsp;&nbsp;&nbsp; Assert(c.height == 480, &quot;NTSC2PAL: input clip must have 480 scan lines&quot;)
&nbsp;&nbsp;&nbsp; Bob(c, height=576)
&nbsp;&nbsp;&nbsp; return Weave()
}</pre>
<p>Even recursive functions can be defined. <br>
  &nbsp; 
<pre>function TRANSITION(clip clip, int start,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int expo, int overlap)
{
&nbsp;&nbsp; return ( start &gt;= clip.framecount-expo ?&nbsp;
&nbsp;&nbsp; \&nbsp;&nbsp; Trim(clip,start,0) :&nbsp;
&nbsp;&nbsp; \&nbsp;&nbsp; Dissolve(Trim(clip,start,start+expo-1),
&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRANSITION(clip,start+expo,expo,overlap),
&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; overlap&nbsp;
&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )
}</pre>
<p> 
<hr>
<h2><a NAME="multiclip"></a>Functions with more than one input clip </h2>
<p>There are some functions which combine two or more clips in different ways. 
  How the video content is calculated is described for each function, but here 
  is a summary which properties the result clip will have. 
<p>The input clips must always have the same color format and - with the exception 
  of <i>Layer</i> - the same dimensions. <br>
  &nbsp; 
<table BORDER >
  <tr> 
    <td></td>
    <td> 
      <center>
        <b>frame-rate</b>
      </center>
    </td>
    <td COLSPAN="2"> 
      <center>
        <b>frame-count</b>
      </center>
    </td>
    <td> 
      <center>
        <b>audio content</b>
      </center>
    </td>
    <td> 
      <center>
        <b>audio sampling rate</b>
      </center>
    </td>
  </tr>
  <tr> 
    <td><b>AlignedSplice, UnalignedSplice</b></td>
    <td ROWSPAN="6"> 
      <center>
        first clip
      </center>
    </td>
    <td> 
      <center>
        sum of all clips
      </center>
    </td>
    <td></td>
    <td> 
      <center>
        see filter description
      </center>
    </td>
    <td ROWSPAN="7"> 
      <center>
        first clip
      </center>
    </td>
  </tr>
  <tr> 
    <td><b>Dissolve</b></td>
    <td> 
      <center>
        sum of all clips minus the overlap
      </center>
    </td>
    <td></td>
    <td> 
      <center>
        see filter description
      </center>
    </td>
  </tr>
  <tr> 
    <td><b>Merge, MergeLuma, MergeChroma, Merge(A)RGB</b></td>
    <td ROWSPAN="2"> 
      <center>
        first clip
      </center>
    </td>
    <td ROWSPAN="5"> 
      <center>
        the last frame <br>
        of the shorter clip <br>
        is repeated until <br>
        the end of the clip
      </center>
    </td>
    <td ROWSPAN="5"> 
      <center>
        first clip
      </center>
    </td>
  </tr>
  <tr> 
    <td><b>Layer</b></td>
  </tr>
  <tr> 
    <td><b>Subtract</b></td>
    <td ROWSPAN="2"> 
      <center>
        longer clip
      </center>
    </td>
  </tr>
  <tr> 
    <td><b>StackHorizontal, StackVertical</b></td>
  </tr>
  <tr> 
    <td><b>Interleave</b></td>
    <td> 
      <center>
        (fps of first clip) <br>
        x <br>
        (number of clips)
      </center>
    </td>
    <td> 
      <center>
        N x frame-count of longer clip
      </center>
    </td>
  </tr>
</table>
<p>As you can see the functions are not completely symmetric but take some attributes 
  from the FIRST clip. <br>
<hr>
<h2><a NAME="Plugins"></a>Plugins </h2>
<p>With these functions you can add external functions to AviSynth. 
<p><code>LoadPlugin</code> (<var>&quot;filename&quot; [, ...]</var>) 
<p>Loads one or more external avisynth plugins (DLLs). <br>
<hr>
<p><code>LoadVirtualDubPlugin</code> (<var>&quot;filename&quot;,
&quot;filtername&quot;, preroll</var>) 
<p>This loads a plugin written for VirtualDub. "filename" is the name of the .vdf 
  file. After calling this function, the filter will be known as "filtername" 
  in avisynth. VirtualDub filters only supports RGB32. If the video happens to 
  be in RGB24-format, then you must use <code>ConvertToRGB32</code> (<code>ConvertToRGB</code> 
  won't suffice). 
<p>Some filters output depends on previous frames; for those preroll should be 
  set to at least the number of frames the filter needs to pre-process to fill 
  its buffers and/or updates its internal variables. <br>
<hr>
<p><code>LoadVFAPIPlugin</code> (<var>&quot;filename&quot;,
&quot;filtername&quot;</var>)
<p>This allows you to use VFAPI plugins (TMPGEnc import plugins).<br>
<hr>
<p><code>LoadCPlugin</code> (<var>&quot;filename&quot; [, ...]</var>)</p>
<p>C-plugins must be loaded with LoadCPlugin.&nbsp; Advice: keep this plugin
outside your auto plugin loading directory to prevent crashes. <a href="http://forum.doom9.org/showthread.php?s=&amp;threadid=58840">[discussion]</a>
<a href="http://kevin.atkinson.dhs.org/avisynth_c/">[AVISynth C API (by
kevina20723)]</a></p>
<hr>
<h2><a NAME="autoloading"></a>Plugin autoload and name precedence <strong>v2</strong></h2>
<p>It is possible to put all plugins and script files with user-defined functions 
  or (global) variables in a directory from where all files with the extension 
  .AVS and .DLL are loaded at startup, unloaded and then loaded dynamically as 
  the script needs them. 
<p>Scripts in this directory should only contain function definitions and global 
  variables, no main processing section (else strange errors may occur), it also 
  is not recommended to put other files in that directory. 
<p>The directory is stored in the registry (the registry key has changed for <strong>v2.5</strong>). 
  You can use double-clicking a .REG-file with the following lines to set the 
  path (of course inserting your actual path): <br>
  &nbsp; 
<pre>REGEDIT4


[HKEY_LOCAL_MACHINE\SOFTWARE\Avisynth]
&quot;plugindir2_5&quot;=&quot;c:\\program files\\avisynth\\plugins&quot;</pre>
<p>The order in which function names take precedence is as follows: 
<pre>user-defined function (always have the highest priority)
   plugin-function (have higher priority than built-in functions - they will override a built-in function)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; built-in function</pre>
<p>Inside those groups the function loaded at last takes precedence, there is 
  no error in a namespace conflict. </p>
<h2><a NAME="autoloading_confl"></a>Plugin autoload and conflicting function
names <strong>v2.55</strong> </h2>
<p>Starting from v2.55 there is DLLName_function() support. The problem is that
two plugins can have different functions which are named the same. To call the
needed one, DLLName_function() support is added. It 
auto-generates the additional names both for auto-loaded plugins and for plugins loaded with
LoadPlugin. </p>
<p><b>Some examples:</b> </p>
<pre># using fielddeinterlace from decomb510.dll
AviSource(&quot;D:\captures\jewel.avi&quot;)
decomb510_fielddeinterlace(blend=false)</pre>
<p>Suppose you have&nbsp; the plugins mpeg2dec.dll and mpeg2dec3.dll in your
auto plugin dir, and you want to load a d2v file with mpeg2dec.dll (which
outputs YUY2): </p>
<pre># using mpeg2source from mpeg2dec.dll
mpeg2dec_mpeg2source(&quot;F:\From_hell\from_hell.d2v&quot;)</pre>
<p>or with mpeg2dec3.dll (which outputs YV12): </p>
<pre># using mpeg2source from mpeg2dec3.dll
mpeg2dec3_mpeg2source(&quot;F:\From_hell\from_hell.d2v&quot;)</pre>
<p><kbd>$Date: 2005/10/26 20:40:51 $</kbd></p>
</body>
</html>
